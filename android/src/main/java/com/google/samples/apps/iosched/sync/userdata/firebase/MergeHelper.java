/*
 * Copyright (c) 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package com.google.samples.apps.iosched.sync.userdata.firebase;

import android.support.annotation.NonNull;
import android.support.annotation.VisibleForTesting;

import com.google.samples.apps.iosched.sync.userdata.UserAction;
import com.google.samples.apps.iosched.sync.userdata.util.UserDataHelper;
import com.google.samples.apps.iosched.util.FirebaseUtils;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Helper class for managing the merge of local and remote user data.
 */
public class MergeHelper {
    /**
     * Holds user data retrieved from the local ContentProvider.
     */
    private final UserDataHelper.UserData mLocalUserData;

    /**
     * Holds user data retrieved from Firebase.
     */
    private final UserDataHelper.UserData mRemoteUserData;

    /**
     * Holds data generated by merging local and remote user data.
     */
    private final UserDataHelper.UserData mMergedUserData;

    public MergeHelper(@NonNull UserDataHelper.UserData localUserData,
            @NonNull UserDataHelper.UserData remoteUserData,
            @NonNull UserDataHelper.UserData mergedUserData) {
        mLocalUserData = checkNotNull(localUserData);
        mRemoteUserData = checkNotNull(remoteUserData);
        mMergedUserData = checkNotNull(mergedUserData);
    }

    @VisibleForTesting
    UserDataHelper.UserData getLocalUserData() {
        return mLocalUserData;
    }

    @VisibleForTesting
    UserDataHelper.UserData getRemoteUserData() {
        return mRemoteUserData;
    }

    @VisibleForTesting
    UserDataHelper.UserData getMergedUserData() {
        return mMergedUserData;
    }

    /**
     * Sets the GCM key for merged user data. Picks the remote GCM key if it exists; otherwise,
     * picks the local GCM key.
     */
    public void mergeGCMKeys() {
        String remoteGcmKey = mRemoteUserData.getGcmKey();
        String localGcmKey = mLocalUserData.getGcmKey();
        mMergedUserData.setGcmKey(remoteGcmKey == null || remoteGcmKey.isEmpty() ? localGcmKey :
                remoteGcmKey);
    }

    /**
     * Processes changes in local user data which were triggered by a user action and which may
     * require a remote Firebase sync. We maintain a flag per data item (see {@link
     * com.google.samples.apps.iosched.provider .ScheduleContract}), and when an item changes, we
     * attempt to sync it.
     *
     * @param actions The user actions that require a remote sync.
     */
    public void mergeUnsyncedActions(final List<UserAction> actions) {
        mMergedUserData.updateVideoIds(mRemoteUserData);
        for (final UserAction action : actions) {
            if (action.requiresSync) {
                if (UserAction.TYPE.VIEW_VIDEO.equals(action.type)) {
                    mMergedUserData.addVideoId(action.videoId);
                }
            }
        }
    }

    /**
     * Builds and returns a Map that can be used when calling {@link com.firebase.client
     * .Firebase#updateChildren(Map)} to update Firebase with a single write.
     *
     * @return A Map where the keys are String paths relative to Firebase root, and the
     * values are the data that is written to those paths.
     */
    public Map<String, Object> getPendingFirebaseUpatesMap() {
        Map<String, Object> pendingFirebaseUpdatesMap = new HashMap<>();
        pendingFirebaseUpdatesMap.put(FirebaseUtils.FIREBASE_NODE_GCM_KEY,
                mMergedUserData.getGcmKey());

        for (String videoID : mMergedUserData.getViewedVideoIds()) {
            pendingFirebaseUpdatesMap.put(FirebaseUtils.getViewedVideoChildPath(videoID), true);
        }
        return pendingFirebaseUpdatesMap;
    }

    /**
     * Throws an exception if {@code userData} is null. Otherwise returns {@code userData}.
     * @param userData  The {@link UserDataHelper.UserData} object that holds the user data.
     */
    private UserDataHelper.UserData checkNotNull(UserDataHelper.UserData userData) {
        if (userData != null) {
            return userData;
        } else {
            throw new IllegalArgumentException("userData must not be null");
        }

    }
}